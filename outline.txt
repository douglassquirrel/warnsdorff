while True:
    knight.write_current_data(f)
    can_move = knight.move()
    if (!can_move):
        break

def get_mins(arr, scorer):
    [select minimum elements from arr according to scorer]

-------------------------

Knight:
_location [Square]
_rule [Rule]
_tiebreak [boolean]

def write_current_state(f):
    f.write(_location.serialise(), _tiebreak)

def move():
    if (_location.has_no_neighbours()):
        return False
    (_location, _tiebreak, _rule) = _rule.apply(_location)
    _location.visited = True
    return True

----------------

Rule:
_ordering [array of 8 integers]
_switch_square [Square]
_next_rule [Rule]

def apply(square):
    (new_square, tiebreak) = square.pick_neighbour(
                {it.square.degree()},
                {ordering.indexOf(it.direction)})
    new_rule = (s.equals(_switch_square) ? _next_rule : self
    return (new_square, tiebreak, new_rule)

----------------

Square:
_board [Board]
visited [boolean]
_x
_y

def degree():
    return _board.get_unvisited_neighbours(self).size

def has_no_neighbours():
    return (0 == self._degree())

def equals(square):
    return (_x == square._x && _y == square._y)

def serialise():
    return [_x, _y]

def pick_neighbour(scorer, tiebreaker):
    neighbours = _board.get_unvisited_neighbours(self)
    candidates = get_mins(neighbours, scorer)
    if (1 == candidates.size):
        return (candidates[0].square, False)  
    choice = get_mins(candidates, tiebreaker)[0].square
    return (choice, True)

----------------------

Board:
_n [int]
_squares [nxn array of Squares]
_directions [array of Directions]

def get_unvisited_neighbours(square):
    return [nbr for nbr in _get_neighbours(square) where nbr.square.visited == False]

def get_square_at(x, y):
    if 0 > x || x >= _n || 0 > y || y >= _n:
        return None
    else:
        return _squares[x][y]

def _get_neighbours(square):
    return [[direction:d.number, square:d.apply(square)] for d in _directions where d.apply(square)]

----------------------

Direction:
_board
_number [int]
_xdelta
_ydelta

apply(square):
    newx = square._x + xdelta
    newy = square._y + ydelta
    return _board.get_square_at(newx, newy)
